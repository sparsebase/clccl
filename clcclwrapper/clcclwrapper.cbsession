[General]
ActiveTab=clcclwrapper

[KBSession]
KBTabs\2\TabFile=clcclwrapper
KBTabs\2\TabName=clcclwrapper
KBTabs\2\KBCache="&compact_paths_global$labelim_p;labelim_pitch$LabelT*;uint$__global;__private$NONE;NONE#count_invalid_labels$labelim_p;labelim_pitch;connectivityim_p;connectivityim_pitch;dcountim_p;dcountim_pitch$LabelT*;uint;ConnectivityPixelT*;uint;uint*;uint$__global;__private;__global;__private;__global;__private$NONE;NONE;NONE;NONE;NONE;NONE#label_tiles$labelim_p;labelim_pitch;connectivityim_p;connectivityim_pitch$LabelT*;uint;ConnectivityPixelT*;uint$__global;__private;__global;__private$NONE;NONE;NONE;NONE#make_connectivity_image$image_p;image_pitch;connectivityim_p;connectivityim_pitch$PixelT*;uint;ConnectivityPixelT*;uint$__global;__private;__global;__private$NONE;NONE;NONE;NONE#make_intra_wg_block_global_sums$intra_wg_block_sums_p;nblocks_to_merge$uint*;uint$__global;__private$NONE;NONE#make_prefix_sums_with_intra_wg_block_global_sums$intra_wg_block_sums_p;array_of_prefix_sums_p;array_of_prefix_sums_pitch;label_count_p$uint*;uint*;uint;LabelT*$__global;__global;__private;__global$NONE;NONE;NONE;NONE#mark_root_classes$image_p;image_pitch;labelim_p;labelim_pitch;is_root_class_image_p;is_root_class_image_pitch$PixelT*;uint;LabelT*;uint;uint*;uint$__global;__private;__global;__private;__global;__private$NONE;NONE;NONE;NONE;NONE;NONE#mark_roots_and_make_intra_wg_block_local_prefix_sums$image_p;image_pitch;labelim_p;labelim_pitch;array_intra_wg_block_sums_p;array_prefix_sum_p;array_prefix_sum_pitch$PixelT*;uint;LabelT*;uint;uint*;uint*;uint$__global;__private;__global;__private;__global;__global;__private$NONE;NONE;NONE;NONE;NONE;NONE;NONE#merge_tiles$block_size_in_row_tiles;block_size_in_col_tiles;nrow_tile_merges;ncol_tile_merges;connectivityim_p;connectivityim_pitch;labelim_p;labelim_pitch;gn_merge_conflicts$uint;uint;uint;uint;ConnectivityPixelT*;uint;LabelT*;uint;uint*$__private;__private;__private;__private;__global;__private;__global;__private;__global$NONE;NONE;NONE;NONE;NONE;NONE;NONE;NONE;NONE#post_merge_convergence_check$block_size_in_row_tiles;block_size_in_col_tiles;nrow_tile_merges;ncol_tile_merges;connectivityim_p;connectivityim_pitch;labelim_p;labelim_pitch;gn_failed_merges$uint;uint;uint;uint;ConnectivityPixelT*;uint;LabelT*;uint;uint*$__private;__private;__private;__private;__global;__private;__global;__private;__global$NONE;NONE;NONE;NONE;NONE;NONE;NONE;NONE;NONE#post_merge_flatten$block_size_in_row_tiles;block_size_in_col_tiles;nrow_tile_merges;ncol_tile_merges;connectivityim_p;connectivityim_pitch;labelim_p;labelim_pitch$uint;uint;uint;uint;ConnectivityPixelT*;uint;LabelT*;uint$__private;__private;__private;__private;__global;__private;__global;__private$NONE;NONE;NONE;NONE;NONE;NONE;NONE;NONE#relabel_with_scanline_order$labelim_out_p;labelim_out_pitch;image_p;image_pitch;labelim_p;labelim_pitch;scanline_prefix_sum_of_root_classes_p;scanline_prefix_sum_of_root_classes_pitch$LabelT*;uint;PixelT*;uint;LabelT*;uint;uint*;uint$__global;__private;__global;__private;__global;__private;__global;__private$NONE;NONE;NONE;NONE;NONE;NONE;NONE;NONE"
KBTabs\2\KBVarsByKernel="compact_paths_global#labelim_p&&;labelim_pitch&&^count_invalid_labels#labelim_p&&;labelim_pitch&&;connectivityim_p&&;connectivityim_pitch&&;dcountim_p&&;dcountim_pitch&&^label_tiles#labelim_p&&;labelim_pitch&&;connectivityim_p&&;connectivityim_pitch&&^make_connectivity_image#image_p&&;image_pitch&&;connectivityim_p&&;connectivityim_pitch&&^make_intra_wg_block_global_sums#intra_wg_block_sums_p&&;nblocks_to_merge&&^make_prefix_sums_with_intra_wg_block_global_sums#intra_wg_block_sums_p&&;array_of_prefix_sums_p&&;array_of_prefix_sums_pitch&&;label_count_p&&^mark_root_classes#image_p&&;image_pitch&&;labelim_p&&;labelim_pitch&&;is_root_class_image_p&&;is_root_class_image_pitch&&^mark_roots_and_make_intra_wg_block_local_prefix_sums#image_p&&;image_pitch&&;labelim_p&&;labelim_pitch&&;array_intra_wg_block_sums_p&&;array_prefix_sum_p&&;array_prefix_sum_pitch&&^merge_tiles#block_size_in_row_tiles&&;block_size_in_col_tiles&&;nrow_tile_merges&&;ncol_tile_merges&&;connectivityim_p&&;connectivityim_pitch&&;labelim_p&&;labelim_pitch&&;gn_merge_conflicts&&^post_merge_convergence_check#block_size_in_row_tiles&&;block_size_in_col_tiles&&;nrow_tile_merges&&;ncol_tile_merges&&;connectivityim_p&&;connectivityim_pitch&&;labelim_p&&;labelim_pitch&&;gn_failed_merges&&^post_merge_flatten#block_size_in_row_tiles&&;block_size_in_col_tiles&&;nrow_tile_merges&&;ncol_tile_merges&&;connectivityim_p&&;connectivityim_pitch&&;labelim_p&&;labelim_pitch&&^relabel_with_scanline_order#labelim_out_p&&;labelim_out_pitch&&;image_p&&;image_pitch&&;labelim_p&&;labelim_pitch&&;scanline_prefix_sum_of_root_classes_p&&;scanline_prefix_sum_of_root_classes_pitch&&"
KBTabs\2\KBRefsByKernel="compact_paths_global#labelim_p&;labelim_pitch&^count_invalid_labels#labelim_p&;labelim_pitch&;connectivityim_p&;connectivityim_pitch&;dcountim_p&;dcountim_pitch&^label_tiles#labelim_p&;labelim_pitch&;connectivityim_p&;connectivityim_pitch&^make_connectivity_image#image_p&;image_pitch&;connectivityim_p&;connectivityim_pitch&^make_intra_wg_block_global_sums#intra_wg_block_sums_p&;nblocks_to_merge&^make_prefix_sums_with_intra_wg_block_global_sums#intra_wg_block_sums_p&;array_of_prefix_sums_p&;array_of_prefix_sums_pitch&;label_count_p&^mark_root_classes#image_p&;image_pitch&;labelim_p&;labelim_pitch&;is_root_class_image_p&;is_root_class_image_pitch&^mark_roots_and_make_intra_wg_block_local_prefix_sums#image_p&;image_pitch&;labelim_p&;labelim_pitch&;array_intra_wg_block_sums_p&;array_prefix_sum_p&;array_prefix_sum_pitch&^merge_tiles#block_size_in_row_tiles&;block_size_in_col_tiles&;nrow_tile_merges&;ncol_tile_merges&;connectivityim_p&;connectivityim_pitch&;labelim_p&;labelim_pitch&;gn_merge_conflicts&^post_merge_convergence_check#block_size_in_row_tiles&;block_size_in_col_tiles&;nrow_tile_merges&;ncol_tile_merges&;connectivityim_p&;connectivityim_pitch&;labelim_p&;labelim_pitch&;gn_failed_merges&^post_merge_flatten#block_size_in_row_tiles&;block_size_in_col_tiles&;nrow_tile_merges&;ncol_tile_merges&;connectivityim_p&;connectivityim_pitch&;labelim_p&;labelim_pitch&^relabel_with_scanline_order#labelim_out_p&;labelim_out_pitch&;image_p&;image_pitch&;labelim_p&;labelim_pitch&;scanline_prefix_sum_of_root_classes_p&;scanline_prefix_sum_of_root_classes_pitch&"
KBTabs\2\KBGroupSizes=0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0$0#0#0#0#0#0
KBTabs\2\KBIterations=1#1#1#1#1#1#1#1#1#1#1#1
KBTabs\2\KBConfigurationNames=config_0$config_0$config_0$config_0$config_0$config_0$config_0$config_0$config_0$config_0$config_0$config_0
KBTabs\2\KBSelectedKernel=compact_paths_global
KBTabs\2\TabCode="//The MIT License (MIT)\r\n//\r\n//Copyright (c) 2015 Jason Newton <nevion@gmail.com>\r\n//\r\n//Permission is hereby granted, free of charge, to any person obtaining a copy\r\n//of this software and associated documentation files (the \"Software\"), to deal\r\n//in the Software without restriction, including without limitation the rights\r\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n//copies of the Software, and to permit persons to whom the Software is\r\n//furnished to do so, subject to the following conditions:\r\n//\r\n//The above copyright notice and this permission notice shall be included in all\r\n//copies or substantial portions of the Software.\r\n//\r\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n//SOFTWARE.\r\n\r\n\r\n#define PREFER_MCL_WORKGROUP_FUNCTIONS\r\n#if __OPENCL_VERSION__ >= 200 && defined(PREFER_MCL_WORKGROUP_FUNCTIONS)\r\n#define USE_CL2_WORKGROUP_FUNCTIONS\r\n#endif\r\n\r\n#include \"clcommons/common.h\"\r\n#include \"clcommons/image.h\"\r\n#include \"clcommons/work_group.h\"\r\n\r\n#ifndef PIXELT\r\n#define PIXELT uint\r\n#endif\r\n#ifndef LABELT\r\n#define LABELT uint\r\n#endif\r\n#ifndef CONNECTIVITYPIXELT\r\n#define CONNECTIVITYPIXELT uint\r\n#endif\r\n#ifndef LDSPIXELT\r\n#define LDSPIXELT uint\r\n#endif\r\n#ifndef LDSLABELT\r\n#define LDSLABELT uint\r\n#endif\r\n#ifndef LDSCONNECTIVITYPIXELT\r\n#define LDSCONNECTIVITYPIXELT uint\r\n#endif\r\n\r\ntypedef PIXELT PixelT;\r\ntypedef LDSPIXELT LDSPixelT;\r\ntypedef LABELT LabelT;\r\ntypedef LDSLABELT LDSLabelT;\r\ntypedef CONNECTIVITYPIXELT ConnectivityPixelT;\r\ntypedef LDSCONNECTIVITYPIXELT LDSConnectivityPixelT;\r\n\r\n#ifndef BG_VALUE\r\n#define BG_VALUE 0\r\n#endif\r\n\r\n#ifndef CONNECTIVITY  //4 or 8\r\n#define CONNECTIVITY 8\r\n#endif\r\n\r\n#ifndef DYNAMIC_IMGDIMS\r\n#define im_rows IMG_ROWS\r\n#define im_cols IMG_COLS\r\n#endif\r\n\r\n#ifndef WORKGROUP_TILE_SIZE_X\r\n#define WORKGROUP_TILE_SIZE_X 32\r\n#endif\r\n#ifndef WORKGROUP_TILE_SIZE_Y\r\n#define WORKGROUP_TILE_SIZE_Y 2\r\n#endif\r\n\r\n#ifndef WORKITEM_REPEAT_X\r\n#define WORKITEM_REPEAT_X 1\r\n#endif\r\n#ifndef WORKITEM_REPEAT_Y\r\n#define WORKITEM_REPEAT_Y 16\r\n#endif\r\n\r\n//work TILEs\r\n#define TILE_COLS (WORKGROUP_TILE_SIZE_X * WORKITEM_REPEAT_X)\r\n#define TILE_ROWS (WORKGROUP_TILE_SIZE_Y * WORKITEM_REPEAT_Y)\r\n\r\n#ifndef FUSED_MARK_KERNEL\r\n#define FUSED_MARK_KERNEL 0\r\n#endif\r\n\r\n__constant const uint UP = (1<<0);\r\n__constant const uint LEFT = (1<<1);\r\n__constant const uint DOWN = (1<<2);\r\n__constant const uint RIGHT = (1<<3);\r\n__constant const uint LEFT_UP = (1<<4);\r\n__constant const uint LEFT_DOWN = (1<<5);\r\n__constant const uint RIGHT_UP = (1<<6);\r\n__constant const uint RIGHT_DOWN = (1<<7);\r\n\r\n#define isConnected(p1, p2) ((p1) == (p2))\r\n#define PASTE2(NAME1, NAME2)   NAME1 ## NAME2\r\n#define pixel_at(type, basename, r, c) image_pixel_at(type, PASTE2(basename, _p), im_rows, im_cols, PASTE2(basename, _pitch), (r), (c))\r\n\r\n#define CONNECTIVITY_TILE_OUTPUT 0\r\n\r\n#define apron_pixel(apron, _t_r, _t_c) apron[(_t_r+ 1)][(_t_c + 1)]\r\n//global dimensions: divUp(im_cols, tile_cols), divUp(im_rows, tile_rows);\r\n__attribute__((reqd_work_group_size(WORKGROUP_TILE_SIZE_X, WORKGROUP_TILE_SIZE_Y, 1)))\r\n__kernel void make_connectivity_image(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    uint im_rows, uint im_cols,\r\n#endif\r\n    __global const PixelT *image_p, uint image_pitch, __global ConnectivityPixelT *connectivityim_p, uint connectivityim_pitch\r\n){\r\n    const uint tile_col_blocksize = TILE_COLS;\r\n    const uint tile_row_blocksize = TILE_ROWS;\r\n    const uint tile_col_block = get_group_id(0) + get_global_offset(0) / get_local_size(0);\r\n    const uint tile_row_block = get_group_id(1) + get_global_offset(1) / get_local_size(1);\r\n    const uint tile_col = get_local_id(0);\r\n    const uint tile_row = get_local_id(1);\r\n\r\n    uint tile_rows = tile_row_blocksize;\r\n    uint tile_cols = tile_col_blocksize;\r\n\r\n    const uint tile_row_start = tile_row_block * tile_rows;\r\n    const uint tile_col_start = tile_col_block * tile_cols;\r\n    const uint tile_row_end = min(tile_row_start + tile_rows, (uint) im_rows);\r\n    const uint tile_col_end = min(tile_col_start + tile_cols, (uint) im_cols);\r\n    //adjust to true tile dimensions\r\n    tile_rows = tile_row_end - tile_row_start;\r\n    tile_cols = tile_col_end - tile_col_start;\r\n    const uint apron_tile_cols = tile_cols + 2;;\r\n    //const uint n_tile_pixels = tile_rows * tile_cols;\r\n    const uint n_work_items = get_local_size(0) * get_local_size(1);\r\n    const uint n_apron_tile_pixels = (tile_rows + 2) * (apron_tile_cols);\r\n    __local LDSPixelT im_tile[TILE_ROWS + 2][TILE_COLS + 2];\r\n\r\n#if CONNECTIVITY_TILE_OUTPUT\r\n    __local LDSConnectivityPixelT connectivity_tile[TILE_ROWS][TILE_COLS];\r\n#endif\r\n\r\n    const uint tid = get_local_linear_id_2();\r\n    for(uint im_tile_fill_task_id = tid; im_tile_fill_task_id < n_apron_tile_pixels; im_tile_fill_task_id += n_work_items){\r\n        const uint im_apron_tile_row = im_tile_fill_task_id / apron_tile_cols;\r\n        const uint im_apron_tile_col = im_tile_fill_task_id % apron_tile_cols;\r\n        const int g_c = ((int)(im_apron_tile_col + tile_col_start)) - 1;\r\n        const int g_r = ((int)(im_apron_tile_row + tile_row_start)) - 1;\r\n\r\n        im_tile[im_apron_tile_row][im_apron_tile_col] = image_tex2D(PixelT, image_p, (int) im_rows, (int) im_cols, image_pitch, g_r, g_c, ADDRESS_ZERO);\r\n    }\r\n    lds_barrier();\r\n\r\n    #pragma unroll\r\n    for (int i = 0; i < WORKITEM_REPEAT_Y; ++i){\r\n        #pragma unroll\r\n        for (int j = 0; j < WORKITEM_REPEAT_X; ++j){\r\n            const uint t_c = get_local_id(0) + WORKGROUP_TILE_SIZE_X * j;\r\n            const uint t_r = get_local_id(1) + WORKGROUP_TILE_SIZE_Y * i;\r\n            const uint c = t_c + tile_col_start;\r\n            const uint r = t_r + tile_row_start;\r\n            PixelT pixel = apron_pixel(im_tile, t_r, t_c);\r\n            ConnectivityPixelT connectivity = 0;\r\n\r\n#if CONNECTIVITY == 8\r\n            connectivity |= c > 0 && r > 0                         && isConnected(pixel, apron_pixel(im_tile, t_r-1, t_c - 1)) ? LEFT_UP : 0;\r\n            connectivity |= c > 0                                  && isConnected(pixel, apron_pixel(im_tile, t_r  , t_c - 1)) ? LEFT : 0;\r\n            connectivity |= c > 0 && r < im_rows - 1               && isConnected(pixel, apron_pixel(im_tile, t_r+1, t_c - 1)) ? LEFT_DOWN : 0;\r\n            connectivity |=          r < im_rows - 1               && isConnected(pixel, apron_pixel(im_tile, t_r+1, t_c    )) ? DOWN : 0;\r\n            connectivity |= c < im_cols - 1 && r < im_rows - 1     && isConnected(pixel, apron_pixel(im_tile, t_r+1, t_c + 1)) ? RIGHT_DOWN : 0;\r\n            connectivity |= c < im_cols - 1                        && isConnected(pixel, apron_pixel(im_tile, t_r  , t_c + 1)) ? RIGHT : 0;\r\n            connectivity |= c < im_cols - 1 && r > 0               && isConnected(pixel, apron_pixel(im_tile, t_r-1, t_c + 1)) ? RIGHT_UP : 0;\r\n            connectivity |=          r > 0                         && isConnected(pixel, apron_pixel(im_tile, t_r-1, t_c    )) ? UP : 0;\r\n#else\r\n            connectivity |= c > 0                                  && isConnected(pixel, apron_pixel(im_tile, t_r  , t_c - 1)) ? LEFT : 0;\r\n            connectivity |=          r < im_rows - 1               && isConnected(pixel, apron_pixel(im_tile, t_r+1, t_c    )) ? DOWN : 0;\r\n            connectivity |= c < im_cols - 1                        && isConnected(pixel, apron_pixel(im_tile, t_r  , t_c + 1)) ? RIGHT : 0;\r\n            connectivity |=          r > 0                         && isConnected(pixel, apron_pixel(im_tile, t_r-1, t_c    )) ? UP : 0;\r\n#endif\r\n            connectivity = (c < im_cols) & (r < im_rows) ? connectivity : 0;\r\n#if CONNECTIVITY_TILE_OUTPUT\r\n            connectivity_tile[t_r][t_c] = connectivity;\r\n#else\r\n            if((c < im_cols) & (r < im_rows)){\r\n                pixel_at(ConnectivityPixelT, connectivityim, r, c) = connectivity;\r\n            }\r\n#endif\r\n\r\n        }\r\n    }\r\n#if CONNECTIVITY_TILE_OUTPUT\r\n    lds_barrier();\r\n\r\n    for(uint im_tile_fill_task_id = tid; im_tile_fill_task_id < n_tile_pixels; im_tile_fill_task_id += n_work_items){\r\n        const uint im_tile_row = im_tile_fill_task_id / tile_cols;\r\n        const uint im_tile_col = im_tile_fill_task_id % tile_cols;\r\n        const uint g_c = im_tile_col + tile_col_start;\r\n        const uint g_r = im_tile_row + tile_row_start;\r\n\r\n        pixel_at(ConnectivityPixelT, connectivityim, g_r, g_c) = connectivity_tile[im_tile_row][im_tile_col];\r\n    }\r\n#endif\r\n}\r\n\r\n__attribute__((reqd_work_group_size(WORKGROUP_TILE_SIZE_X, WORKGROUP_TILE_SIZE_Y, 1)))\r\n__kernel void label_tiles(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    uint im_rows, uint im_cols,\r\n#endif\r\n    __global LabelT *labelim_p, uint labelim_pitch, __global const ConnectivityPixelT *connectivityim_p, uint connectivityim_pitch\r\n){\r\n    const uint tile_col_blocksize = TILE_COLS;\r\n    const uint tile_row_blocksize = TILE_ROWS;\r\n    const uint tile_col_block = get_group_id(0) + get_global_offset(0) / get_local_size(0);\r\n    const uint tile_row_block = get_group_id(1) + get_global_offset(1) / get_local_size(1);\r\n\r\n    uint tile_rows = tile_row_blocksize;\r\n    uint tile_cols = tile_col_blocksize;\r\n\r\n    const uint tile_row_start = tile_row_block * tile_rows;\r\n    const uint tile_col_start = tile_col_block * tile_cols;\r\n    const uint tile_row_end = min(tile_row_start + tile_rows, (uint) im_rows);\r\n    const uint tile_col_end = min(tile_col_start + tile_cols, (uint) im_cols);\r\n    //adjust to true tile dimensions\r\n    tile_rows = tile_row_end - tile_row_start;\r\n    tile_cols = tile_col_end - tile_col_start;\r\n\r\n    __local LDSLabelT label_tile_im[TILE_ROWS][TILE_COLS];\r\n#ifdef SHM_EDGE_TILE\r\n    __local LDSConnectivityPixelT  edge_tile_im[TILE_ROWS][TILE_COLS];\r\n#endif\r\n\r\n    LDSLabelT new_labels[WORKITEM_REPEAT_Y][WORKITEM_REPEAT_X];\r\n    LDSLabelT old_labels[WORKITEM_REPEAT_Y][WORKITEM_REPEAT_X];\r\n#ifndef SHM_EDGE_TILE\r\n    LDSConnectivityPixelT edges[WORKITEM_REPEAT_Y][WORKITEM_REPEAT_X];\r\n#endif\r\n\r\n    #pragma unroll\r\n    for (int i = 0; i < WORKITEM_REPEAT_Y; ++i){\r\n        #pragma unroll\r\n        for (int j = 0; j < WORKITEM_REPEAT_X; ++j){\r\n            const uint tile_row = get_local_id(1) + WORKGROUP_TILE_SIZE_Y * i;\r\n            const uint tile_col = get_local_id(0) + WORKGROUP_TILE_SIZE_X * j;\r\n            const bool valid_pixel_task = (tile_col < tile_cols) & (tile_row < tile_rows);\r\n            ConnectivityPixelT c = valid_pixel_task ? pixel_at(ConnectivityPixelT, connectivityim, tile_row_start + tile_row, tile_col_start + tile_col) : 0;\r\n\r\n            c = tile_col == 0 ? c & ~(LEFT|LEFT_DOWN|LEFT_UP) : c;\r\n            c = tile_row == 0 ? c & ~(UP|LEFT_UP|RIGHT_UP) : c;\r\n\r\n            c = tile_col >= tile_cols - 1 ? c & ~(RIGHT|RIGHT_DOWN|RIGHT_UP) : c;\r\n            c = tile_row >= tile_rows - 1 ? c & ~(DOWN|LEFT_DOWN|RIGHT_DOWN) : c;\r\n\r\n            new_labels[i][j] = valid_pixel_task ? tile_row * tile_cols + tile_col : ((LDSLabelT) -1);\r\n#ifdef SHM_EDGE_TILE\r\n            edge_tile_im[tile_row][tile_col] = c;\r\n#else\r\n            edges[i][j] = c;\r\n#endif\r\n        }\r\n    }\r\n\r\n    for (uint k = 0; ;++k){\r\n        //make copies\r\n        #pragma unroll\r\n        for (int i = 0; i < WORKITEM_REPEAT_Y; ++i){\r\n            #pragma unroll\r\n            for (int j = 0; j < WORKITEM_REPEAT_X; ++j){\r\n                const uint tile_row = get_local_id(1) + WORKGROUP_TILE_SIZE_Y * i;\r\n                const uint tile_col = get_local_id(0) + WORKGROUP_TILE_SIZE_X * j;\r\n                old_labels[i][j] = new_labels[i][j];\r\n                label_tile_im[tile_row][tile_col] = new_labels[i][j];\r\n            }\r\n        }\r\n        lds_barrier();\r\n\r\n        //take minimum label of local neighboorhood - single writer, multi reader version\r\n        #pragma unroll\r\n        for (int i = 0; i < WORKITEM_REPEAT_Y; ++i){\r\n            #pragma unroll\r\n            for (int j = 0; j < WORKITEM_REPEAT_X; ++j){\r\n                const uint tile_row = get_local_id(1) + WORKGROUP_TILE_SIZE_Y * i;\r\n                const uint tile_col = get_local_id(0) + WORKGROUP_TILE_SIZE_X * j;\r\n\r\n#ifdef SHM_EDGE_TILE\r\n                const ConnectivityPixelT connectivity = edge_tile_im[tile_row][tile_col];\r\n#else\r\n                const ConnectivityPixelT connectivity = edges[i][j];\r\n#endif\r\n                LDSLabelT label = new_labels[i][j];\r\n\r\n#if CONNECTIVITY == 8\r\n                label = connectivity & UP            ? min(label, label_tile_im[tile_row - 1][tile_col - 0]) : label;\r\n                label = connectivity & LEFT_UP       ? min(label, label_tile_im[tile_row - 1][tile_col - 1]) : label;\r\n                label = connectivity & LEFT          ? min(label, label_tile_im[tile_row - 0][tile_col - 1]) : label;\r\n                label = connectivity & LEFT_DOWN     ? min(label, label_tile_im[tile_row + 1][tile_col - 1]) : label;\r\n                label = connectivity & DOWN          ? min(label, label_tile_im[tile_row + 1][tile_col - 0]) : label;\r\n                label = connectivity & RIGHT_DOWN    ? min(label, label_tile_im[tile_row + 1][tile_col + 1]) : label;\r\n                label = connectivity & RIGHT         ? min(label, label_tile_im[tile_row + 0][tile_col + 1]) : label;\r\n                label = connectivity & RIGHT_UP      ? min(label, label_tile_im[tile_row - 1][tile_col + 1]) : label;\r\n#else\r\n                label = connectivity & UP            ? min(label, label_tile_im[tile_row - 1][tile_col - 0]) : label;\r\n                label = connectivity & LEFT          ? min(label, label_tile_im[tile_row - 0][tile_col - 1]) : label;\r\n                label = connectivity & DOWN          ? min(label, label_tile_im[tile_row + 1][tile_col - 0]) : label;\r\n                label = connectivity & RIGHT         ? min(label, label_tile_im[tile_row + 0][tile_col + 1]) : label;\r\n#endif\r\n\r\n                new_labels[i][j] = label;\r\n            }\r\n        }\r\n        lds_barrier();\r\n\r\n        __local uint changed;\r\n        if((get_local_id(1) == 0) & (get_local_id(0) == 0)){\r\n            changed = 0;\r\n        }\r\n        lds_barrier();\r\n\r\n        uint pchanged = 0;\r\n        #pragma unroll\r\n        for(int i = 0; i < WORKITEM_REPEAT_Y; ++i){\r\n            #pragma unroll\r\n            for(int j = 0; j < WORKITEM_REPEAT_X; ++j){\r\n                const uint tile_row = get_local_id(1) + WORKGROUP_TILE_SIZE_Y * i;\r\n                const uint tile_col = get_local_id(0) + WORKGROUP_TILE_SIZE_X * j;\r\n                const uint old_label = old_labels[i][j];\r\n                pchanged += atomic_min(&label_tile_im[old_label / tile_cols][old_label % tile_cols], new_labels[i][j]) > new_labels[i][j];\r\n            }\r\n        }\r\n        atomic_add(&changed, pchanged);\r\n        lds_barrier();\r\n\r\n        //if there are no updates, we are finished\r\n        if(!changed){\r\n            break;\r\n        }\r\n\r\n        //Compact paths\r\n        #pragma unroll\r\n        for(int i = 0; i < WORKITEM_REPEAT_Y; ++i){\r\n            #pragma unroll\r\n            for(int j = 0; j < WORKITEM_REPEAT_X; ++j){\r\n                const uint tile_row = get_local_id(1) + WORKGROUP_TILE_SIZE_Y * i;\r\n                const uint tile_col = get_local_id(0) + WORKGROUP_TILE_SIZE_X * j;\r\n                const bool valid_pixel_task = (tile_col < tile_cols) & (tile_row < tile_rows);\r\n                if(valid_pixel_task){\r\n                    LDSLabelT label = new_labels[i][j];\r\n                    //find root label\r\n                    while(label_tile_im[label / tile_cols][label % tile_cols] < label){\r\n                        label = label_tile_im[label / tile_cols][label % tile_cols];\r\n                    }\r\n\r\n                    new_labels[i][j] = label;\r\n                }\r\n            }\r\n        }\r\n        lds_barrier();\r\n    }\r\n\r\n    //save with adjusted global (untiled) labels\r\n    #pragma unroll\r\n    for(int i = 0; i < WORKITEM_REPEAT_Y; ++i){\r\n        #pragma unroll\r\n        for(int j = 0; j < WORKITEM_REPEAT_X; ++j){\r\n            const LabelT tile_label = new_labels[i][j];\r\n            //convert the tile label into it's 2-D equivilent\r\n            const uint l_g_r = (tile_label / tile_cols) + tile_row_start;\r\n            const uint l_g_c = (tile_label % tile_cols) + tile_col_start;\r\n\r\n            const uint tile_row = get_local_id(1) + WORKGROUP_TILE_SIZE_Y * i;\r\n            const uint tile_col = get_local_id(0) + WORKGROUP_TILE_SIZE_X * j;\r\n            const uint g_r = tile_row_start + tile_row;\r\n            const uint g_c = tile_col_start + tile_col;\r\n\r\n            //adjust to global offset and convert to scanline order again - this is globally unique\r\n            const LabelT glabel = l_g_r * im_cols + l_g_c;\r\n            const bool valid_pixel_task = (g_c < im_cols) & (g_r < im_rows);\r\n            if(valid_pixel_task){\r\n                assert_val(tile_label < tile_rows * tile_cols, tile_label);\r\n                pixel_at(LabelT, labelim, g_r, g_c) = glabel;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninline\r\nLabelT find_root_global(__global LabelT *labelim_p, uint labelim_pitch, LabelT label\r\n#ifdef DYNAMIC_IMGDIMS\r\n    , const uint im_rows, const uint im_cols\r\n#else\r\n    ,const uint d1, const uint d2\r\n#endif\r\n){\r\n    for(;;){\r\n        const uint y = label / im_cols;\r\n        const uint x = label % im_cols;\r\n        assert_val(y < im_rows, y);\r\n        assert_val(x < im_cols, x);\r\n        const LabelT parent = pixel_at(LabelT, labelim, y, x);\r\n\r\n        if(label == parent){\r\n            break;\r\n        }\r\n\r\n        label = parent;\r\n    }\r\n    return label;\r\n}\r\n\r\ninline\r\nLabelT find_root_global_uncached(__global LabelT *labelim_p, uint labelim_pitch, LabelT label\r\n#ifdef DYNAMIC_IMGDIMS\r\n    ,const uint im_rows, const uint im_cols\r\n#else\r\n    ,const uint d1, const uint d2\r\n#endif\r\n){\r\n    for(;;){\r\n        const uint r = label / im_cols;\r\n        const uint c = label % im_cols;\r\n        assert_val(r < im_rows, r);\r\n        assert_val(c < im_cols, c);\r\n        LabelT parent = atomic_load(&pixel_at(LabelT, labelim, r, c));\r\n\r\n        if(label == parent){\r\n            break;\r\n        }\r\n\r\n        label = parent;\r\n    }\r\n    return label;\r\n}\r\n\r\n__kernel void compact_paths_global(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#endif\r\n    __global LabelT *labelim_p, uint labelim_pitch){\r\n    const uint x = get_global_id(0);\r\n    const uint y = get_global_id(1);\r\n\r\n    if((x < im_cols) & (y < im_rows)){\r\n        const LabelT label = pixel_at(LabelT, labelim, y, x);\r\n        pixel_at(LabelT, labelim, y, x) = find_root_global(labelim_p, labelim_pitch, label, im_rows, im_cols);\r\n    }\r\n}\r\n\r\n#ifndef MERGE_CONFLICT_STATS\r\n#define MERGE_CONFLICT_STATS 0\r\n#endif\r\n\r\nuint merge_edge_labels(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#else\r\n    const uint d1, const uint d2,\r\n#endif\r\n    __global LabelT *labelim_p, const uint labelim_pitch, uint l1_r, uint l1_c, uint l2_r, uint l2_c, __global uint *conflicts){\r\n    LabelT l1 = atomic_load(&pixel_at(LabelT, labelim, l1_r, l1_c));\r\n    LabelT l2 = atomic_load(&pixel_at(LabelT, labelim, l2_r, l2_c));\r\n    if(l1 == l2){\r\n        return 0;\r\n    }\r\n    LabelT r1 = find_root_global_uncached(labelim_p, labelim_pitch, l1, im_rows, im_cols);\r\n    LabelT r2 = find_root_global_uncached(labelim_p, labelim_pitch, l2, im_rows, im_cols);\r\n    if(r1 == r2){\r\n        return 0;\r\n    }\r\n    LabelT mi = min(r1, r2);\r\n    LabelT ma = max(r1, r2);\r\n    uint ret = 0;\r\n\r\n    for(;;){\r\n\r\n        //const uint mi_y = mi / im_cols;\r\n        //const uint mi_x = mi % im_cols;\r\n        const uint ma_y = ma / im_cols;\r\n        const uint ma_x = ma % im_cols;\r\n\r\n        __global LabelT *ma_lp = &pixel_at(LabelT, labelim, ma_y, ma_x);\r\n        const LabelT old_label_of_ma = atomic_min(ma_lp, mi);\r\n\r\n        if(old_label_of_ma >= mi){\r\n            //printf(\"merge successful with mi = %d ma = %d old_label_ma: %d\\n\", mi, ma, old_label_of_ma);\r\n            ret = old_label_of_ma == mi ? 0 : 1;\r\n            break;\r\n        }\r\n#if MERGE_CONFLICT_STATS\r\n        atomic_inc(conflicts);\r\n#endif\r\n\r\n        //printf(\"condition detected with mi = %d ma = %d old_label_ma: %d\\n\", mi, ma, old_label_of_ma);\r\n        //else somebody snuck in and made the max label now smaller than ours! we need to now retry to merge\r\n        l1 = atomic_load(&pixel_at(LabelT, labelim, l1_r, l1_c));\r\n        l2 = atomic_load(&pixel_at(LabelT, labelim, l2_r, l2_c));\r\n\r\n        r1 = find_root_global_uncached(labelim_p, labelim_pitch, l1, im_rows, im_cols);\r\n        r2 = find_root_global_uncached(labelim_p, labelim_pitch, l2, im_rows, im_cols);\r\n        if(r1 == r2){\r\n            break;\r\n        }\r\n        mi = min(r1, r2);\r\n        ma = max(r1, r2);\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n#define MERGE_BOTH_EDGES 0\r\n#define NWAY_MERGE_IN_ROW_TILES 2\r\n#define NWAY_MERGE_IN_COL_TILES 2\r\n#define nway_merge_in_row_tiles NWAY_MERGE_IN_ROW_TILES\r\n#define nway_merge_in_col_tiles NWAY_MERGE_IN_COL_TILES\r\n\r\n#define MERGE_TILE_HEADER                                                                                                 \\\r\n    size_t rmerge_job_id;                                                                                                 \\\r\n    size_t cmerge_job_id;                                                                                                 \\\r\n    if((nrow_tile_merges > 0) & (ncol_tile_merges > 0)){                                                                  \\\r\n        rmerge_job_id = get_group_id(0) / ncol_tile_merges;                                                               \\\r\n        cmerge_job_id = get_group_id(0) % ncol_tile_merges;                                                               \\\r\n        assert_val(rmerge_job_id < nrow_tile_merges, rmerge_job_id);                                                      \\\r\n        assert_val(cmerge_job_id < ncol_tile_merges, cmerge_job_id);                                                      \\\r\n    }else if(nrow_tile_merges > 0){/*ncol_tile_merges = 0*/                                                               \\\r\n        rmerge_job_id = get_group_id(0);                                                                                  \\\r\n        cmerge_job_id = 0;                                                                                                \\\r\n        assert_val(rmerge_job_id < nrow_tile_merges, rmerge_job_id);                                                      \\\r\n    }else{/*nrow_tile_merges = 0*/                                                                                        \\\r\n        rmerge_job_id = 0;                                                                                                \\\r\n        cmerge_job_id = get_group_id(0);                                                                                  \\\r\n        assert_val(cmerge_job_id < ncol_tile_merges, cmerge_job_id);                                                      \\\r\n    }                                                                                                                     \\\r\n                                                                                                                          \\\r\n    const size_t tid = get_local_id(0);                                                                                   \\\r\n    const uint rmerge_block_index_start = (rmerge_job_id + 0) * block_size_in_row_tiles * nway_merge_in_row_tiles;        \\\r\n    const uint rmerge_block_index_end = (rmerge_job_id + 1) * block_size_in_row_tiles * nway_merge_in_row_tiles;          \\\r\n    const uint rmerge_start = rmerge_block_index_start * TILE_ROWS;                                                       \\\r\n    const uint rmerge_end = min(rmerge_block_index_end * TILE_ROWS, im_rows);                                             \\\r\n    const uint cmerge_block_index_start = (cmerge_job_id + 0) * block_size_in_col_tiles * nway_merge_in_col_tiles;        \\\r\n    const uint cmerge_block_index_end = (cmerge_job_id + 1) * block_size_in_col_tiles * nway_merge_in_col_tiles;          \\\r\n    const uint cmerge_start = cmerge_block_index_start * TILE_COLS;                                                       \\\r\n    const uint cmerge_end = min(cmerge_block_index_end * TILE_COLS, im_cols);                                             \\\r\n                                                                                                                          \\\r\n    const size_t line_wg_id = get_group_id(1);                                                                            \\\r\n    const size_t nline_workers = get_num_groups(1);                                                                       \\\r\n    const size_t wg_size = get_local_size(0);                                                                             \\\r\n    const size_t line_block_size = wg_size;/*efficient block size*/\r\n\r\n#define BLOCKED_LINE_HEADER(start, end)                                                                                                                   \\\r\n    const size_t nline_blocks = divUp((end) - (start), line_block_size);/*number of efficiently processible blocks*/                                      \\\r\n    const size_t nline_blocks_per_wg = nline_blocks / nline_workers;                                                                                      \\\r\n    const size_t nline_blocks_remainder = nline_blocks - (nline_workers * nline_blocks_per_wg);                                                           \\\r\n    const size_t nline_blocks_to_left = nline_blocks_per_wg * line_wg_id + (line_wg_id < nline_blocks_remainder ? line_wg_id : nline_blocks_remainder);   \\\r\n    const size_t n_wg_blocks = nline_blocks_per_wg + (line_wg_id < nline_blocks_remainder ? 1 : 0);                                                       \\\r\n    const size_t line_start_index = nline_blocks_to_left * line_block_size + (start);                                                                     \\\r\n    const size_t line_end_index = min(line_start_index + n_wg_blocks * line_block_size, (size_t)(end));/*block aligned end*/\r\n\r\n//ncalls: logUp(ntiles, nway_merge)\r\n//group size: k, 1: k can be anything\r\n//gdims: roundUpToMultiple(im_cols, k), nmerges : nmerges = ntiles // (nway_merge * block_size)\r\n//block_size: nway_merge^(call_index) for call_index=[0, ncalls): 1<=block_size<=nway_merge^(logUp(nhorz_tiles, nway_merge)-1)\r\n//a horizontal merge spanning vertically in cols\r\n__kernel void merge_tiles(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#endif\r\n    const uint block_size_in_row_tiles,\r\n    const uint block_size_in_col_tiles,\r\n    const uint nrow_tile_merges, const uint ncol_tile_merges,\r\n    const __global ConnectivityPixelT *connectivityim_p, const uint connectivityim_pitch,\r\n    __global LabelT *labelim_p, const uint labelim_pitch\r\n    ,__global uint *gn_merge_conflicts\r\n){\r\n    MERGE_TILE_HEADER\r\n\r\n    uint pn_merge_conflicts;\r\n    do{\r\n        __local uint n_merge_conflicts;\r\n        if(tid == 0){\r\n            n_merge_conflicts = 0;\r\n        }\r\n        lds_barrier();\r\n        pn_merge_conflicts = 0;\r\n        if(nrow_tile_merges){\r\n            BLOCKED_LINE_HEADER(cmerge_start, cmerge_end)\r\n            assert_val(block_size_in_row_tiles * TILE_ROWS < im_rows, block_size_in_row_tiles * TILE_ROWS);\r\n            assert_val(block_size_in_row_tiles < divUp(im_rows, TILE_ROWS), block_size_in_row_tiles);\r\n            for(uint rmerge_sub_index = 1; rmerge_sub_index < nway_merge_in_row_tiles; rmerge_sub_index++){\r\n                const uint rmerge_block_index = rmerge_block_index_start + block_size_in_row_tiles * rmerge_sub_index;\r\n                assert_val(rmerge_sub_index < nway_merge_in_row_tiles, rmerge_sub_index);\r\n                if((cmerge_start != cmerge_end) & (tid == 0)){\r\n                    assert_val(r < im_rows, r);\r\n                }\r\n                {\r\n                    const uint r = rmerge_block_index * TILE_ROWS;//the middle point to merge about\r\n                    //merge along the columns - ie this merges to horizontally seperated tiles\r\n\r\n                    for(uint c = line_start_index + tid; c < line_end_index; c += get_local_size(0)){\r\n                    //for(uint c = cmerge_start + tid; c < cmerge_end; c += get_local_size(0)){\r\n                        const ConnectivityPixelT e = pixel_at(ConnectivityPixelT, connectivityim, r, c);\r\n\r\n                        if(e & UP){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r - 1, c, gn_merge_conflicts);\r\n                        }\r\n                        #if CONNECTIVITY == 8\r\n                        if(e & LEFT_UP){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r - 1, c - 1, gn_merge_conflicts);\r\n                        }\r\n                        if(e & RIGHT_UP){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r - 1, c + 1, gn_merge_conflicts);\r\n                        }\r\n                        #endif\r\n                    }\r\n                }\r\n                #if MERGE_BOTH_EDGES\r\n                {\r\n                    const uint r = rmerge_block_index * TILE_ROWS - 1;//the middle point to merge about\r\n                    //merge along the columns - ie this merges to horizontally seperated tiles\r\n                    for(uint c = line_start_index + tid; c < line_end_index; c += get_local_size(0)){\r\n                    //for(uint c = cmerge_start + tid; c < cmerge_end; c += get_local_size(0)){\r\n                        const ConnectivityPixelT e = pixel_at(ConnectivityPixelT, connectivityim, r, c);\r\n                        if(e & DOWN){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r + 1, c, gn_merge_conflicts);\r\n                        }\r\n                        #if CONNECTIVITY == 8\r\n                        if(e & LEFT_DOWN){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r + 1, c - 1, gn_merge_conflicts);\r\n                        }\r\n                        if(e & RIGHT_DOWN){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r + 1, c + 1, gn_merge_conflicts);\r\n                        }\r\n                        #endif\r\n                    }\r\n                }\r\n                #endif\r\n            }\r\n        }\r\n\r\n        if(ncol_tile_merges){\r\n            BLOCKED_LINE_HEADER(rmerge_start, rmerge_end)\r\n\r\n            assert_val(block_size_in_col_tiles < divUp(im_cols, TILE_COLS), block_size_in_col_tiles);\r\n            assert_val(block_size_in_col_tiles * TILE_COLS < im_cols, block_size_in_col_tiles * TILE_COLS);\r\n            for(uint cmerge_sub_index = 1; cmerge_sub_index < nway_merge_in_col_tiles; cmerge_sub_index++){\r\n                const uint cmerge_block_index = cmerge_block_index_start + block_size_in_col_tiles * cmerge_sub_index;\r\n                assert_val(cmerge_sub_index < nway_merge_in_row_tiles, cmerge_sub_index);\r\n                if((rmerge_start != rmerge_end) & (tid == 0)){\r\n                    assert_val(c < im_cols, c);\r\n                }\r\n                {\r\n                    const uint c = cmerge_block_index * TILE_COLS;//the middle point to merge about\r\n                    //merge along the rows - ie this merges to vertically seperated tiles\r\n                    //for(uint r = rmerge_start + tid; r < rmerge_end; r += get_local_size(0)){\r\n                    for(uint r = line_start_index + tid; r < line_end_index; r += get_local_size(0)){\r\n\r\n                        const ConnectivityPixelT e = pixel_at(ConnectivityPixelT, connectivityim, r, c);\r\n                        if(e & LEFT){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r, c - 1, gn_merge_conflicts);\r\n                        }\r\n                        #if CONNECTIVITY == 8\r\n                        if(e & LEFT_UP){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r - 1, c - 1, gn_merge_conflicts);\r\n                        }\r\n                        if(e & LEFT_DOWN){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r + 1, c - 1, gn_merge_conflicts);\r\n                        }\r\n                        #endif\r\n                    }\r\n                }\r\n                #if MERGE_BOTH_EDGES\r\n                {\r\n                    const uint c = cmerge_block_index * TILE_COLS - 1;//the middle point to merge about\r\n                    //merge along the rows - ie this merges to vertically seperated tiles\r\n                    //for(uint r = rmerge_start + tid; r < rmerge_end; r += get_local_size(0)){\r\n                    for(uint r = line_start_index + tid; r < line_end_index; r += get_local_size(0)){\r\n                        //if(r >= 2003 && r < 2012 &&  c >= 1183 && c < 1185){\r\n                        //    printf(\"%d %d %d\\n\", r, c, lc);\r\n                        //}\r\n\r\n                        const ConnectivityPixelT e = pixel_at(ConnectivityPixelT, connectivityim, r, c);\r\n                        if(e & RIGHT){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r, c + 1, gn_merge_conflicts);\r\n                        }\r\n                        #if CONNECTIVITY == 8\r\n                        if(e & RIGHT_UP){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r - 1, c + 1, gn_merge_conflicts);\r\n                        }\r\n                        if(e & RIGHT_DOWN){\r\n                            pn_merge_conflicts += merge_edge_labels(im_rows, im_cols, labelim_p, labelim_pitch, r, c, r + 1, c + 1, gn_merge_conflicts);\r\n                        }\r\n                        #endif\r\n                    }\r\n                }\r\n                #endif\r\n            }\r\n        }\r\n\r\n        //if(tid == 0){\r\n        //    printf(\"merge_tile_on_rows nway_merge: %d merge_job_id: %d/%d merge_sub_index: %d merge_blocK_index: %d block_size: %d row: %d\\n\", nway_merge, merge_job_id, get_num_groups(1), merge_sub_index, merge_block_index, block_size, r);\r\n        //}\r\n        atomic_add(&n_merge_conflicts, pn_merge_conflicts);\r\n        lds_barrier();\r\n        pn_merge_conflicts = n_merge_conflicts;\r\n    }while(pn_merge_conflicts);\r\n}\r\n\r\n__kernel void post_merge_convergence_check(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#endif\r\n    const uint block_size_in_row_tiles,\r\n    const uint block_size_in_col_tiles,\r\n    const uint nrow_tile_merges, const uint ncol_tile_merges,\r\n    const __global ConnectivityPixelT *connectivityim_p, const uint connectivityim_pitch,\r\n    const __global LabelT *labelim_p, const uint labelim_pitch\r\n    ,__global uint *gn_failed_merges\r\n){\r\n    MERGE_TILE_HEADER\r\n\r\n    uint pn_failed_merges;\r\n    __local uint n_failed_merges;\r\n    if(tid == 0){\r\n        n_failed_merges = 0;\r\n    }\r\n    lds_barrier();\r\n    pn_failed_merges = 0;\r\n    if(nrow_tile_merges){\r\n        BLOCKED_LINE_HEADER(cmerge_start, cmerge_end)\r\n        assert_val(block_size_in_row_tiles * TILE_ROWS < im_rows, block_size_in_row_tiles * TILE_ROWS);\r\n        assert_val(block_size_in_row_tiles < divUp(im_rows, TILE_ROWS), block_size_in_row_tiles);\r\n        #pragma unroll\r\n        for(uint rmerge_sub_index = 1; rmerge_sub_index < nway_merge_in_row_tiles; rmerge_sub_index++){\r\n            const uint rmerge_block_index = rmerge_block_index_start + block_size_in_row_tiles * rmerge_sub_index;\r\n            assert_val(rmerge_sub_index < nway_merge_in_row_tiles, rmerge_sub_index);\r\n            if((cmerge_start != cmerge_end) & (tid == 0)){\r\n                assert_val(r < im_rows, r);\r\n            }\r\n            {\r\n                const uint r = rmerge_block_index * TILE_ROWS;//the middle point to merge about\r\n                //merge along the columns - ie this merges to horizontally seperated tiles\r\n                for(uint c = line_start_index + tid; c < line_end_index; c += get_local_size(0)){\r\n                //for(uint c = cmerge_start + tid; c < cmerge_end; c += get_local_size(0)){\r\n                    const ConnectivityPixelT e = pixel_at(ConnectivityPixelT, connectivityim, r, c);\r\n\r\n                    const LabelT l1 = pixel_at(LabelT, labelim, r, c);\r\n                    //const LabelT r1 = find_root_global(labelim_p, labelim_pitch, l1, im_rows, im_cols);\r\n                    if(e & UP){\r\n                        const LabelT l2 = pixel_at(LabelT, labelim, r - 1, c);\r\n                        //const LabelT r2 = find_root_global(labelim_p, labelim_pitch, l2, im_rows, im_cols);\r\n                        pn_failed_merges += l1 != l2;\r\n                    }\r\n                    #if CONNECTIVITY == 8\r\n                    if(e & LEFT_UP){\r\n                        const LabelT l2 = pixel_at(LabelT, labelim, r - 1, c - 1);\r\n                        pn_failed_merges += l1 != l2;\r\n                    }\r\n                    if(e & RIGHT_UP){\r\n                        const LabelT l2 = pixel_at(LabelT, labelim, r - 1, c + 1);\r\n                        pn_failed_merges += l1 != l2;\r\n                    }\r\n                    #endif\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if(ncol_tile_merges){\r\n        BLOCKED_LINE_HEADER(rmerge_start, rmerge_end)\r\n        assert_val(block_size_in_col_tiles < divUp(im_cols, TILE_COLS), block_size_in_col_tiles);\r\n        assert_val(block_size_in_col_tiles * TILE_COLS < im_cols, block_size_in_col_tiles * TILE_COLS);\r\n        #pragma unroll\r\n        for(uint cmerge_sub_index = 1; cmerge_sub_index < nway_merge_in_col_tiles; cmerge_sub_index++){\r\n            const uint cmerge_block_index = cmerge_block_index_start + block_size_in_col_tiles * cmerge_sub_index;\r\n            assert_val(cmerge_sub_index < nway_merge_in_row_tiles, cmerge_sub_index);\r\n            if((rmerge_start != rmerge_end) & (tid == 0)){\r\n                assert_val(c < im_cols, c);\r\n            }\r\n            {\r\n                const uint c = cmerge_block_index * TILE_COLS;//the middle point to merge about\r\n                //merge along the rows - ie this merges to vertically seperated tiles\r\n                //for(uint r = rmerge_start + tid; r < rmerge_end; r += get_local_size(0)){\r\n                for(uint r = line_start_index + tid; r < line_end_index; r += get_local_size(0)){\r\n\r\n                    const ConnectivityPixelT e = pixel_at(ConnectivityPixelT, connectivityim, r, c);\r\n                    const LabelT l1 = pixel_at(LabelT, labelim, r, c);\r\n                    //const LabelT r1 = find_root_global(labelim_p, labelim_pitch, l1, im_rows, im_cols);\r\n                    if(e & LEFT){\r\n                        const LabelT l2 = pixel_at(LabelT, labelim, r, c - 1);\r\n                        pn_failed_merges += l1 != l2;\r\n                    }\r\n                    #if CONNECTIVITY == 8\r\n                    if(e & LEFT_UP){\r\n                        const LabelT l2 = pixel_at(LabelT, labelim, r - 1, c - 1);\r\n                        pn_failed_merges += l1 != l2;\r\n                    }\r\n                    if(e & LEFT_DOWN){\r\n                        const LabelT l2 = pixel_at(LabelT, labelim, r + 1, c - 1);\r\n                        pn_failed_merges += l1 != l2;\r\n                    }\r\n                    #endif\r\n                }\r\n            }\r\n        }\r\n    }\r\n    atomic_add(&n_failed_merges, pn_failed_merges);\r\n    lds_barrier();\r\n    if(tid == 0){\r\n        atomic_add(gn_failed_merges, n_failed_merges);\r\n    }\r\n}\r\n\r\n//ncalls: logUp(ntiles, nway_merge)\r\n//group size: k, 1: k can be anything\r\n//gdims: roundUpToMultiple(im_cols, k), nmerges : nmerges = ntiles // (nway_merge * block_size)\r\n//block_size: nway_merge^(call_index) for call_index=[0, ncalls): 1<=block_size<=nway_merge^(logUp(nhorz_tiles, nway_merge)-1)\r\n//a horizontal merge spanning vertically in cols\r\n__kernel void post_merge_flatten(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#endif\r\n    const uint block_size_in_row_tiles,\r\n    const uint block_size_in_col_tiles,\r\n    const uint nrow_tile_merges, const uint ncol_tile_merges,\r\n    const __global ConnectivityPixelT *connectivityim_p, const uint connectivityim_pitch,\r\n    __global LabelT *labelim_p, const uint labelim_pitch\r\n){\r\n    MERGE_TILE_HEADER\r\n\r\n    if(nrow_tile_merges){\r\n        BLOCKED_LINE_HEADER(cmerge_start, cmerge_end)\r\n        assert_val(block_size_in_row_tiles * TILE_ROWS < im_rows, block_size_in_row_tiles * TILE_ROWS);\r\n        assert_val(block_size_in_row_tiles < divUp(im_rows, TILE_ROWS), block_size_in_row_tiles);\r\n        for(uint rmerge_sub_index = 1; rmerge_sub_index < nway_merge_in_row_tiles; rmerge_sub_index++){\r\n            const uint rmerge_block_index = rmerge_block_index_start + block_size_in_row_tiles * rmerge_sub_index;\r\n            assert_val(rmerge_sub_index < nway_merge_in_row_tiles, rmerge_sub_index);\r\n            if((cmerge_start != cmerge_end) & (tid == 0)){\r\n                assert_val(r < im_rows, r);\r\n            }\r\n            #pragma unroll\r\n            for(uint i = 0; i < 2; ++i){\r\n                const uint r = rmerge_block_index * TILE_ROWS - i;//the middle point to merge about\r\n                //flatten along the columns - ie flattens on the line to horizontally seperated tiles\r\n                //for(uint c = cmerge_start + tid; c < cmerge_end; c += get_local_size(0)){\r\n                for(uint c = line_start_index + tid; c < line_end_index; c += get_local_size(0)){\r\n                    const LabelT label = pixel_at(LabelT, labelim, r, c);\r\n                    pixel_at(LabelT, labelim, r, c) = find_root_global(labelim_p, labelim_pitch, label, im_rows, im_cols);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if(ncol_tile_merges){\r\n        BLOCKED_LINE_HEADER(rmerge_start, rmerge_end)\r\n\r\n        assert_val(block_size_in_col_tiles < divUp(im_cols, TILE_COLS), block_size_in_col_tiles);\r\n        assert_val(block_size_in_col_tiles * TILE_COLS < im_cols, block_size_in_col_tiles * TILE_COLS);\r\n        for(uint cmerge_sub_index = 1; cmerge_sub_index < nway_merge_in_col_tiles; cmerge_sub_index++){\r\n            const uint cmerge_block_index = cmerge_block_index_start + block_size_in_col_tiles * cmerge_sub_index;\r\n            assert_val(cmerge_sub_index < nway_merge_in_row_tiles, cmerge_sub_index);\r\n            if((rmerge_start != rmerge_end) & (tid == 0)){\r\n                assert_val(c < im_cols, c);\r\n            }\r\n            #pragma unroll\r\n            for(uint i = 0; i < 2; ++i){\r\n                const uint c = cmerge_block_index * TILE_COLS - i;//the middle point to merge about\r\n                //merge along the rows - ie this merges to vertically seperated tiles\r\n                //for(uint r = line_start_index + tid; r < line_end_index; r += get_local_size(0)){\r\n                for(uint r = rmerge_start + tid; r < rmerge_end; r += get_local_size(0)){\r\n                    const LabelT label = pixel_at(LabelT, labelim, r, c);\r\n                    pixel_at(LabelT, labelim, r, c) = find_root_global(labelim_p, labelim_pitch, label, im_rows, im_cols);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n__kernel void mark_root_classes(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#endif\r\n    __global PixelT *image_p, uint image_pitch,\r\n    __global const LabelT* labelim_p, const uint labelim_pitch,\r\n    __global uint* is_root_class_image_p, const uint is_root_class_image_pitch\r\n){\r\n    const uint c = get_global_id(0);\r\n    const uint r = get_global_id(1);\r\n    const bool valid_pixel_task = (c < im_cols) & (r < im_rows);\r\n\r\n    const uint linear_index = c + r * im_cols;\r\n    if(valid_pixel_task){\r\n        const PixelT pixel = pixel_at(PixelT, image, r, c);\r\n        const LabelT label = pixel_at(LabelT, labelim, r, c);\r\n        pixel_at(uint, is_root_class_image, r, c) = (pixel != BG_VALUE) & (label == linear_index);\r\n    }\r\n}\r\n\r\n#ifndef USE_CL2_WORKGROUP_FUNCTIONS\r\nMAKE_WORK_GROUP_FUNCTIONS(uint, uint, 0U, UINT_MAX)\r\n#endif\r\n\r\n#define PREFIX_SUM_HEADER                                                                                                                \\\r\n    const uint narray_workers = get_num_groups(0);                                                                                       \\\r\n    const uint array_length = im_rows * im_cols;                                                                                         \\\r\n    const uint array_wg_id = get_group_id(0);                                                                                            \\\r\n    const uint wg_size = get_local_size(0);                                                                                              \\\r\n    const uint block_size = wg_size;/*efficient block size*/                                                                             \\\r\n    const uint nblocks = divUp(array_length, block_size);/*number of efficiently processible blocks*/                                    \\\r\n    const uint nblocks_per_wg = nblocks / narray_workers;                                                                                \\\r\n    const uint nblocks_to_merge = nblocks / nblocks_per_wg;                                                                              \\\r\n    const uint nblocks_remainder = nblocks - (narray_workers * nblocks_per_wg);                                                          \\\r\n    const uint nblocks_to_left = nblocks_per_wg * array_wg_id + (array_wg_id < nblocks_remainder ? array_wg_id : nblocks_remainder);     \\\r\n    const uint n_wg_blocks = nblocks_per_wg + (array_wg_id < nblocks_remainder ? 1 : 0);                                                 \\\r\n                                                                                                                                         \\\r\n    const uint start_index = nblocks_to_left * block_size;                                                                               \\\r\n    const uint end_index_ = start_index + n_wg_blocks * block_size;/*block aligned end*/\r\n\r\n//root class inclusive prefix sums belonging to each compute unit given to each tile - note if narray_workers == 1, no merge step is necessary\r\n//computes local prefix sums to get intra-wg blocksums, prefix sum that to get intra-wg offsets - this is needed to merge the final blocksums\r\n//global dims: <wgs_per_histogram, n_tiles>, work_dims: <wg_size, 1>\r\n//global blocksums[divUp(nblocks, blocks_per_wg)]\r\n#ifdef GPU_ARCH\r\n__attribute__((reqd_work_group_size(DEVICE_WAVEFRONT_SIZE, 1, 1)))\r\n#endif\r\n__kernel void mark_roots_and_make_intra_wg_block_local_prefix_sums(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#endif\r\n    __global const PixelT *image_p, uint image_pitch,\r\n    __global const LabelT* labelim_p, const uint labelim_pitch,\r\n    __global uint * restrict array_intra_wg_block_sums_p,\r\n    __global uint * restrict array_prefix_sum_p, const uint array_prefix_sum_pitch\r\n){\r\n\r\n    PREFIX_SUM_HEADER\r\n    (void) nblocks_to_merge;\r\n    uint inter_block_sum = 0;\r\n\r\n    for(uint linear_index = get_local_id(0) + start_index; linear_index < end_index_; linear_index += wg_size){\r\n        const uint r = linear_index / im_cols;\r\n        const uint c = linear_index % im_cols;\r\n\r\n        uint count = 0;\r\n        if(linear_index < array_length){\r\n#if FUSED_MARK_KERNEL\r\n            const PixelT pixel = pixel_at(PixelT, image, r, c);\r\n            const LabelT label = pixel_at(LabelT, labelim, r, c);\r\n            count = ((pixel != BG_VALUE) & (label == linear_index)) ? 1 : 0;\r\n#else\r\n            count = pixel_at(uint, array_prefix_sum, r, c);\r\n#endif\r\n        }\r\n\r\n#ifdef USE_CL2_WORKGROUP_FUNCTIONS\r\n        uint block_prefix_sum_inclusive = work_group_scan_inclusive_add(count);\r\n#else\r\n#ifdef GPU_ARCH\r\n        __local uint lmem[WORK_GROUP_FUNCTION_MEMORY_SIZE_POWER2_(DEVICE_WAVEFRONT_SIZE)];\r\n#else\r\n        __local uint lmem[WORK_GROUP_FUNCTION_MAX_MEMORY_SIZE];\r\n#endif\r\n        uint block_prefix_sum_inclusive = clc_work_group_scan_inclusive_add_uint(count, lmem);\r\n#endif\r\n\r\n        block_prefix_sum_inclusive += inter_block_sum;\r\n        if(linear_index < array_length){\r\n            pixel_at(uint, array_prefix_sum, r, c) = block_prefix_sum_inclusive;\r\n        }\r\n#ifdef USE_CL2_WORKGROUP_FUNCTIONS\r\n        inter_block_sum = work_group_broadcast(block_prefix_sum_inclusive, wg_size - 1);\r\n#else\r\n        __local uint value;\r\n        inter_block_sum = clc_work_group_broadcast1_uint(block_prefix_sum_inclusive, wg_size - 1, &value);\r\n#endif\r\n    }\r\n    if((array_intra_wg_block_sums_p != 0) & (get_local_id(0) == wg_size - 1)){\r\n        array_intra_wg_block_sums_p[array_wg_id] = inter_block_sum;\r\n    }\r\n}\r\n\r\n//exclusive prefix sums intra-wg blocksums to get intra-wg offsets - needed to merge together all the wg-local prefix sums\r\n//global dims: <1, n_tiles>, work_dims: <wg_size, 1>\r\n//global tile_intra_wg_block_sums[n_tiles][nblocks_to_merge]\r\n#ifdef GPU_ARCH\r\n__attribute__((reqd_work_group_size(DEVICE_WAVEFRONT_SIZE, 1, 1)))\r\n#endif\r\n__kernel void make_intra_wg_block_global_sums(\r\n    __global uint * restrict intra_wg_block_sums_p, uint nblocks_to_merge\r\n){\r\n    const uint wg_size = get_local_size(0);\r\n\r\n    __local uint intra_wg_block_sums[WG_SIZE_MAX + 1];\r\n    if(get_local_id(0) == 0){\r\n        intra_wg_block_sums[0] = 0;\r\n    }\r\n    lds_barrier();\r\n    uint intra_wg_block_offset = 0;\r\n\r\n    for(uint intra_wg_block_id = get_local_id(0); intra_wg_block_id < divUp(nblocks_to_merge, wg_size) * wg_size; intra_wg_block_id += wg_size){\r\n        //get the unsumed blocksums\r\n        const uint intra_wg_block_sum = intra_wg_block_id < nblocks_to_merge ? intra_wg_block_sums_p[intra_wg_block_id] : 0;\r\n        intra_wg_block_sums[get_local_id(0) + 1] = intra_wg_block_sum;\r\n        lds_barrier();\r\n\r\n        const uint intra_wg_block_sum_delayed = intra_wg_block_sums[get_local_id(0)];\r\n#ifdef USE_CL2_WORKGROUP_FUNCTIONS\r\n        intra_wg_block_offset += work_group_scan_inclusive_add(intra_wg_block_sum_delayed);\r\n#else\r\n        __local uint lmem[WORK_GROUP_FUNCTION_MAX_MEMORY_SIZE];\r\n        intra_wg_block_offset += clc_work_group_scan_inclusive_add_uint(intra_wg_block_sum_delayed, lmem);\r\n#endif\r\n        if(intra_wg_block_id < nblocks_to_merge){\r\n            intra_wg_block_sums_p[intra_wg_block_id] = intra_wg_block_offset;\r\n        }\r\n#ifdef USE_CL2_WORKGROUP_FUNCTIONS\r\n        intra_wg_block_offset = work_group_broadcast(intra_wg_block_offset, wg_size - 1);\r\n#else\r\n        __local uint value;\r\n        intra_wg_block_offset = clc_work_group_broadcast1_uint(intra_wg_block_offset, wg_size - 1, &value);\r\n#endif\r\n\r\n        if(get_local_id(0) == wg_size-1){\r\n            intra_wg_block_sums[0] = intra_wg_block_sums[wg_size];\r\n        }\r\n        lds_barrier();\r\n    }\r\n}\r\n\r\n//merges global offsets of intra-wg-block offsets of prefix sums\r\n//global dims: <wgs_per_sum>, work_dims: <wg_size> : wg_size >= nblocks_to_merge\r\n//global array_of_prefix_sums[im_rows*im_cols] : as input partial sums, as output full prefix sum\r\n#ifdef GPU_ARCH\r\n__attribute__((reqd_work_group_size(DEVICE_WAVEFRONT_SIZE, 1, 1)))\r\n#endif\r\n__kernel void make_prefix_sums_with_intra_wg_block_global_sums(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#endif\r\n    __global const uint * restrict intra_wg_block_sums_p,\r\n    __global uint * restrict array_of_prefix_sums_p, uint array_of_prefix_sums_pitch,\r\n    __global LabelT* label_count_p\r\n){\r\n    PREFIX_SUM_HEADER\r\n    (void) nblocks_to_merge;\r\n\r\n    const uint inter_block_sum = intra_wg_block_sums_p[array_wg_id];\r\n    for(uint linear_index = get_local_id(0) + start_index; linear_index < end_index_; linear_index += wg_size){\r\n        if(linear_index < array_length){\r\n            const uint r = linear_index / im_cols;\r\n            const uint c = linear_index % im_cols;\r\n            const uint count = image_pixel_at(uint, array_of_prefix_sums_p, im_rows, im_cols, array_of_prefix_sums_pitch, r, c) + inter_block_sum;\r\n            if(linear_index == array_length - 1){\r\n                *label_count_p = count + 1;//include BG\r\n            }\r\n            image_pixel_at(uint, array_of_prefix_sums_p, im_rows, im_cols, array_of_prefix_sums_pitch, r, c) = count;\r\n        }\r\n    }\r\n}\r\n\r\n__kernel void relabel_with_scanline_order(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#endif\r\n    __global LabelT* labelim_out_p, const uint labelim_out_pitch,\r\n    __global const PixelT* image_p, const uint image_pitch,\r\n    __global const LabelT* labelim_p, const uint labelim_pitch,\r\n    __global uint* scanline_prefix_sum_of_root_classes_p, const uint scanline_prefix_sum_of_root_classes_pitch\r\n){\r\n    const uint c = get_global_id(0);\r\n    const uint r = get_global_id(1);\r\n    const bool valid_pixel_task = (c < im_cols) & (r < im_rows);\r\n\r\n    if(valid_pixel_task){\r\n        const PixelT pixel = pixel_at(PixelT, image, r, c);\r\n        LabelT final_label = 0;\r\n        if(pixel != BG_VALUE){\r\n            const LabelT label = pixel_at(LabelT, labelim, r, c);\r\n            const uint label_r = label / im_cols;\r\n            const uint label_c = label % im_cols;\r\n            final_label = pixel_at(uint, scanline_prefix_sum_of_root_classes, label_r, label_c);\r\n        }\r\n        pixel_at(LabelT, labelim_out, r, c) = final_label;\r\n    }\r\n}\r\n\r\n__kernel void count_invalid_labels(\r\n#ifdef DYNAMIC_IMGDIMS\r\n    const uint im_rows, const uint im_cols,\r\n#endif\r\n    __global const LabelT* labelim_p, const uint labelim_pitch,\r\n    __global const ConnectivityPixelT *connectivityim_p, const uint connectivityim_pitch,\r\n    __global const uint *dcountim_p, const uint dcountim_pitch\r\n){\r\n    const uint c = get_global_id(0);\r\n    const uint r = get_global_id(1);\r\n    const bool valid_pixel_task = (c < im_cols) & (r < im_rows);\r\n\r\n    if(valid_pixel_task){\r\n        const ConnectivityPixelT connectivity = pixel_at(ConnectivityPixelT, connectivityim, r, c);\r\n        const LabelT label = pixel_at(LabelT, labelim, r, c);\r\n        uint dcount = 0;\r\n\r\n        dcount += connectivity & UP         ? label != pixel_at(LabelT, labelim, r - 1, c - 0) : 0;\r\n        dcount += connectivity & LEFT_UP    ? label != pixel_at(LabelT, labelim, r - 1, c - 1) : 0;\r\n        dcount += connectivity & LEFT       ? label != pixel_at(LabelT, labelim, r - 0, c - 1) : 0;\r\n        dcount += connectivity & LEFT_DOWN  ? label != pixel_at(LabelT, labelim, r + 1, c - 1) : 0;\r\n        dcount += connectivity & DOWN       ? label != pixel_at(LabelT, labelim, r + 1, c - 0) : 0;\r\n        dcount += connectivity & RIGHT_DOWN ? label != pixel_at(LabelT, labelim, r + 1, c + 1) : 0;\r\n        dcount += connectivity & RIGHT      ? label != pixel_at(LabelT, labelim, r + 0, c + 1) : 0;\r\n        dcount += connectivity & RIGHT_UP   ? label != pixel_at(LabelT, labelim, r - 1, c + 1) : 0;\r\n\r\n        pixel_at(uint, dcountim, r, c) = dcount;\r\n    }\r\n}\r\n"
KBTabs\2\KBFacadeVisible=true
KBTabs\2\IsValidation=false
KBTabs\2\KBServerActive=true
KBTabs\2\Artifacts="C:\\project\\clccl\\clcclwrapper\\kernels.ir;C:\\project\\clccl\\clcclwrapper\\kernels.asm;C:\\project\\clccl\\clcclwrapper\\kernels.ll;C:\\project\\clccl\\clcclwrapper\\kernels_x64.ll;C:\\project\\clccl\\clcclwrapper\\kernels_x64.spir;C:\\project\\clccl\\clcclwrapper\\kernels_x86.ll;C:\\project\\clccl\\clcclwrapper\\kernels_x86.spir;C:\\project\\clccl\\clcclwrapper\\kernels_x86.spirv;C:\\project\\clccl\\clcclwrapper\\kernels_x64.spirv;C:\\project\\clccl\\clcclwrapper\\kernels_x86.txtspirv;C:\\project\\clccl\\clcclwrapper\\kernels_x64.txtspirv;"
KBTabs\2\Reports=
KBTabs\2\CLFiles=C:\\project\\clccl\\clcclwrapper\\kernels.cl
KBTabs\2\IsBinary=false
KBTabs\2\TabOpt6="-D GPU_ARCH -cl-std=CL1.2 -D DEVICE_WAVEFRONT_SIZE=32 -D WG_SIZE_MAX=1024 -D PIXELT=uint -D LABELT=uint -D WORKGROUP_TILE_SIZE_X=16 -D WORKGROUP_TILE_SIZE_Y=16 -D WORKITEM_REPEAT_X=4 -D WORKITEM_REPEAT_Y=1 -D FUSED_MARK_KERNEL=0 -D ENABLE_MERGE_CONFLICT_STATS=0 -D IMAGE_MAD_INDEXING -D IMG_ROWS=512u -D IMG_COLS=512u  -I \"C:\\project\\clcommons\\include\""
KBTabs\2\TabOpt7=2
KBTabs\2\TabOpt10=(local) ROLLINGSTONE
KBTabs\2\TabOpt17=Intel(R) OpenCL
KBTabs\2\TabOpt18=CPU: Intel(R) Core(TM) i7-6700K CPU @ 4.00GHz
KBTabs\2\TabOpt1=true
KBTabs\2\TabOpt3=false
KBTabs\2\TabOpt9=Current Operating System
KBTabs\2\TabOpt11=
KBTabs\2\TabOpt4=false
KBTabs\2\TabOpt13=5010
KBTabs\2\TabOpt14=5999
KBTabs\2\TabOpt15=true
KBTabs\2\TabOpt16=20000
KBTabs\size=2
